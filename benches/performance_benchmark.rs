use criterion::{black_box, criterion_group, criterion_main, Criterion, BenchmarkId};

use hmeasure::{CostRatioDensity, HMeasure};
use hmeasure::{BetaParams, BinaryClassParams, BinaryClassifierScores};

fn hmeasure_benchmark(cr: &mut Criterion) {
    let base = 100;
    let mut group = cr.benchmark_group("hmeasure_benchmark");
    for size in [base, 2 * base, 4 * base, 8 * base, 16 * base, 32*base, 64*base, 128*base, 256*base].iter() {
        group.bench_with_input(BenchmarkId::from_parameter(size), size, |b, &size| {
            b.iter(|| run_hmeasure(black_box(size)));
        });
    }
    group.finish();
}

fn run_hmeasure(size: usize) -> Option<f64>{
    /* Choose beta parameters for the model scores distributions that illustrate
    the case of a model that is able to reasonably discriminate between the two classes
    => the score distributions generated by the model are fairly distinct, albeit not
     completely partitioned.*/
    let c0_a: f64 = 2.0;
    let c1_a: f64 = 6.0;
    let c0_b: f64 = 6.0;
    let c1_b: f64 = 2.0;
    let c0_n: usize = size;
    let c1_n: usize = size;
    // seed the random number generator for reproducibility.
    let mut rng = BinaryClassifierScores::generate_rng(13);
    let class0_params = BetaParams { alpha: c0_a, beta: c0_b };
    let class1_params = BetaParams { alpha: c1_a, beta: c1_b };
    let bcp = &BinaryClassParams { class0: class0_params, class1: class1_params };
    let mut bcs = BinaryClassifierScores::new(&bcp, c0_n, c1_n, &mut rng);

    // specify a cost ratio density
    let cost_density_params = BetaParams { alpha: 2.0, beta: 2.0 };
    let crd = CostRatioDensity::new(cost_density_params);

    // calculate the H-Measure given the cost ratio density and scores
    let mut hm = HMeasure::new(crd, None, None);
    let scores = &mut bcs.scores;
    let _ = hm.h_measure(scores);
    hm.h
}

criterion_group!(benches, hmeasure_benchmark);
criterion_main!(benches);