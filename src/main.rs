mod datagen;
mod hmeasure;

use crate::hmeasure::{CostRatioDensity, HMeasure};
pub use self::datagen::{BetaParams, BinaryClassParams, BinaryClassifierScores};

pub fn example_hmeasure(){
    // Choose beta parameters for the model scores distributions that illustrate
    // the case of a model that is able to reasonably discriminate between the two classes
    // => the score distributions generated by the model are fairly distinct, albeit not
    // completely partitioned.
    let mut c0_a: f64 = 2.0;
    let mut c1_a: f64 = 2.0;
    let mut c0_b: f64 = 2.0;
    let mut c1_b: f64 = 2.0;
    let c0_n: usize = 2000;
    let c1_n: usize = 2000; // different population size in each class: imbalanced problem
    for _ in 0..10 {
        let class0_params = BetaParams { alpha: c0_a, beta: c0_b };
        let class1_params = BetaParams { alpha: c1_a, beta: c1_b };
        let bcp = &BinaryClassParams { class0: class0_params, class1: class1_params };
        let mut bcs = BinaryClassifierScores::new(&bcp, c0_n, c1_n);
        bcs.generate_samples();

        let cost_density_params = BetaParams { alpha: 2.0, beta: 2.0 };
        let crd = CostRatioDensity::new(cost_density_params);
        let mut hm = HMeasure::new(crd, None, None);
        let scores = &mut bcs.scores;
        let hmr = hm.h_measure(scores);
        println!("H-Measure results: {:?} : {:?}", (c0_a, c0_b, c1_a, c1_b), hmr.h);
        if hmr.h > 0.2 {
            let result_set = format!("{}_{}_{}_{}", c0_a, c0_b, c1_a, c1_b);
            let file_path = "./";
            hmr.save(result_set.as_str(), file_path);
        }
        // c0_a += 0.25;
        // c0_b -= 0.25;
        // c1_a -= 0.25;
        // c1_b += 0.25;
    }
}

fn main() {
    example_hmeasure()
}
